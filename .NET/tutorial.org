#+TITLE:        .NET Core Learning Docs
#+AUTHOR:       Likhon Barai
#+EMAIL:        likhonhere007@gmail.com
#+DATE:         [2025-Aug-03 Sun]
#+TAGS:   blog .NET tutorial programming framework

:PROPERTIES:
#+OPTIONS:
:END:


* Table of Contents                                                     :toc:
- [[#how-aspnet-works][How ASP.NET works]]
  - [[#api][API]]
  - [[#middleware][Middleware]]
- [[#git-ignore-auto-generated-files][Git ignore auto generated files]]
- [[#migrations][Migrations]]
- [[#angular][Angular]]
  - [[#install-angular-cli][Install Angular CLI]]
  - [[#ngx-bootstrap][ngx-bootstrap]]
  - [[#create-components][Create Components]]
  - [[#install-toastr][Install Toastr]]
  - [[#create-interceptor-with-angular-cli][Create Interceptor with Angular CLI]]
- [[#sqlite][SQLite]]

* How ASP.NET works
/References/: https://learn.microsoft.com/en-us/training/modules/introduction-to-aspnet-core/3-how-aspnet-core-works
The most basic ASP.NET Core app's Program.cs file:
#+begin_src c++ c#
  var builder = WebApplication.CreateBuilder(args);
  var app = builder.Build();

  app.MapGet("/", () => "Hello World!");

  app.Run();
#+end_src
With the previous code:
- A basic ASP.NET Core web application is set up that listen for HTTP GET requests at the root URL("/") and responds with "Hello World!".
- The app is initialized, configures a single route, and starts the web server.

** COMMENT Blazor
You can build interactive web UI with ASP.NET Core using Blazor.
A reusable Blazor components, such as the following =Counter= component is defined in a /Counter.razor/ file:
#+begin_src css
  @page "/counter"
  @rendermode InteractiveServer

  <PageTitle>Counter</PageTitle>

  <h1>Counter</h1>

  <p role="status">Current count: @currentCount</p>

  <button class="btn btn-primary" @onclick="IncrementCount">Click me</button>

  @code {
      private int currentCount = 0;
      private void IncrementCount()
      {
          currentCount++;
      }
  }
#+end_src

The =Counter= component can be added to any web page in the app by adding the =<Counter />= element.
#+begin_src
  @page "/"

  <PageTitle>Home</PageTitle>

  <h1>Hello, world!</h1>

  <Counter />
#+end_src

** API
ASP.NET Core provides frameworks for building APIs, gRPC services, and real-time apps with SignalR to instantly push data updates to clients.
Basic Minimal API:
#+begin_src C++
  var builder = WebApplication.CreateBuilder();
  var app = builder.Build();

  app.MapGet("/hello", () => "Hello, World!");

  app.Run();
#+end_src
With the previous code:
- A minimal API is set up that listens for HTTP GET requests at the =/hello= URL and responds with /"Hello, World!"/.
- The =WebApplicationBuilder= is used to configure the app.
- The =MapGet= method defines a route and a handler for GET requests.

** Middleware
ASP.NET Core uses a pipeline of middleware components to handle HTTP requests and responses. This modular approach provides flexibility, allowing you to customize and extend your application's functionality by adding or removing middleware components as needed.

The middleware pipeline processes HTTP requests in a sequential manner, ensuring that each component can perform its designated task before passing the requests to the next component in the pipeline.

Adding build-in middleware in the /Program.cs/ file:
#+begin_src C++
  var builder = WebApllication.CreateBuilder(args);
  var app = builder.Build();

  app.UserHttpsRedirection();

  app.UseRouting();

  app.MapStaticAssets();

  app.UseAuthentication();

  app.UseAuthorization();

  app.MapGet("/", () => "Hello World!");

  app.Run();
#+end_src

In the previous code, several common middleware components were added:
- *UseHttpsRedirection*: Redirects HTTP requests to HTTPS.
- *UseRouting*: Enables routing to map requests to endpoints.
- *MapStaticAssets*: Optimizes the delivery of static file such as HTML, CSS, JavaScript, images, and other assets.
- *UseAuthentication*: Adds authentication capabilities.
- *UseAuthorization*: Adds authorization capabilities.
- *app.MapGet*: This is a simple endpoint to demonstrate that the application is running.

* Git ignore auto generated files
To ignore *.NET* project folder compiler files, lots of *DLLs* for code that's
generated by the compiler itself. Now inside our git repository, we don't need
to store code that's auto generated by our compiler. We only want to store in
our code repository the things that we've written. We don't need to save changes
that can be easily recreated by the compiler. So we need to effectively exclude
a lot of this stuff from our git repository. And one of the things we can use to
help us with that is something that we can get from the *.NET CLI*. So If I run =dotnet new list=:
#+begin_src sh
  $ dotnet new list
  These templates matched your input:

  Template Name                                 Short Name                  Language    Tags
  --------------------------------------------  --------------------------  ----------  ----------------------------------
  API Controller                                apicontroller               [C#]        Web/ASP.NET
  ASP.NET Core Empty                            web                         [C#],F#     Web/Empty
  ...
  dotnet gitignore file                         gitignore,.gitignore                    Config
  ...
#+end_src
 and take a look whats available inside here, then we have inside this list
somewhere is a =dotnet gitignore file=. And we can create this command:
#+begin_src sh
  dotnet new gitignore
#+end_src
and it's going to automatically contain the configuration which is going to
ignore all of those files that are auto generated by the compiler.

- Now another thing we might want to exclude from saving into our source control
  is possibly: ~appsettings.json~ as well. Because this is gonna contain our
  configuration. There will be sensitive information (/eg. API keys, secret
  strings/) that we don't want anyone else to see on a public GitHub repository.

* Migrations
Update Database schema using migrations:
~dotnet ef migrations add UserEntityUpdated~

- Remove Migrations
  =dotnet ef migrations remove=
  this will successfully remove the migrations if we does not applied migrations to Database.
- Apply Migrations
  ~dotnet ef database update~
- Delete a Database
  =dotnet ef database drop=

* Angular
To see which =Angular= version we have Installed, we can use CLI command: =ng version= or =ng v=.
** Install Angular CLI
#+begin_src sh
  $ npm install -g @angular/cli
  # And you want to Install specific version of Angular
  $ npm install -g @angular/cli@17 # --version 17
#+end_src

- Check installed Anguler version in linux by command line?
  =ng v=
** ngx-bootstrap
*** Installation
- Angular CLI way
  =ng add ngx-bootstrap=
- Manual way
  =npm install ngx-bootstrap --save=
- Install bootstrap with font-awesome
  =npm install ngx-bootstrap bootstrap font-awesome=
- And to Install a specific version of bootstrap, you can mention it in:
  =npm install ngx-bootstrap@20 bootstrap font-awesome=
** Create Components
=ng generate --help=
=ng generate component=
=ng g c --help=
=ng g c nav --dry-run= (nav is the name of component) NOTE: The `--dry-run` option means no changes were made.
=ng g c nav --skip-tests=
- generate a service: =ng g s _services/account --dry-run=
- generate route guard definition: =ng g g _guards/auth--skip-test

** Install Toastr
=npm install ngx-toastr=

** Create Interceptor with Angular CLI
=ng g interceptor _interceptors/error --skip-tests=
* SQLite
~sqlite3 /home/likhon/dotnet/DatingApp/API/dating.db~
