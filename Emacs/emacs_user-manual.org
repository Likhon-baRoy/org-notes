#+TITLE:  Emacs User Manual
#+AUTHOR: Likhon Barai
#+EMAIL:  likhonhere007@gmail.com
#+DATE:   2022 Dec 13
#+TAGS:   blog emacs
#+PROPERTY: header-args :tangle yes :comments yes :result silent

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://thomasf.github.io/solarized-css/solarized-dark.min.css" />

:DRAWERNAME:
üìù *NOTE:* (/for Beginners/) I personally prefer Emacs built-in TUTORIAL first,
which is very well documented and easy to understand. In this documentation I'll use
=Ctrl= as =C=, =Alt= as =M=, =Shift= as =S=, =Space= as =SPC= and =BackSpace= as
=BS=.

/This documentation is still in progress, so you better stick to it. cheers!/ üçª
:END:

* Table of Contents                                                     :TOC:

- [[#basics-of-emacs][Basics of Emacs]]
  - [[#moving-around][Moving Around]]
  - [[#files][Files]]
- [[#modeline][Modeline]]
- [[#search][Search]]
- [[#mark/unmark][Mark/Unmark]]
- [[#getting-help][Getting Help]]
- [[#killing-and-delete][Killing and Deleting]]
- [[#undo/redo][Undo/Redo]]
- [[#tweaks][Tweaks]]
- [[#window-and-frames][Window and Frames]]
- [[#repeat-command][Repeat Command]]
- [[#build-in-programs][Build in Programs]]
  - [[#dired][Dired]]
  - [[#eww][eww]]
- [[#shells][Shells]]
- [[#sexps][SEXPS]]
- [[#fold/unfold-blocks][Fold/Unfold Blocks]]
- [[#bookmarks][Bookmarks]]
- [[#registers][Registers]]
- [[#keyboard-macros][Keyboard Macros]]
- [[#miscellaneous][Miscellaneous]]
  - [[#enter-numeric-values][Enter Numeric values]]
- [[#projectile][Projectile]]
- [[#org][ORG]]
- [[#Spelling-check][Spelling Check]]

* Basics of Emacs
** Moving Around in the Buffer
General Shortcuts
|------------+-----------------------------------+---------------------------------------------------------|
| Keystrokes | Command Name                      | Action                                                  |
|------------+-----------------------------------+---------------------------------------------------------|
| C-n        | next-line                         | move to next line (Down)                                  |
| C-p        | previous-line                     | move to previous line (Up)                            |
| C-f        | forward-char                      | move forward one char (Right)                           |
| C-b        | backward-char                     | move backward one char (Left)                           |
| M-f        | forward-word                      | move one forward                                        |
| M-b        | backward-word                     | move one word backward                                  |
| C-e        | end-of-line                       | move to end of line                                     |
| C-a        | beginning-of-line                 | move to beginning of line                               |
| M-e        | forward-sentence                  | move forward one sentence                               |
| M-a        | backwards-sentence                | move backwards one sentence                             |
| M-}        | forward-paragraph                 | move forward one paragraph                              |
| M-{        | backwards-paragraph               | move backwards one paragraph                            |
| C-v        | scroll-up                         | move forward one screen                                 |
| M-v        | scroll-down                       | move backward one screen                                |
| C-x [      | forward-page                      | move forward one page                                   |
| C-x ]      | backward-page                     | move backward one page                                  |
| M-<        | beginning-of-buffer               | move to beginning of file                               |
| M->        | end-of-buffer                     | move to end of file                                     |
| C-l        | recenter-top-bottom               | Scroll current line to center, top, bottom              |
| M-r        | move-to-window-line-top-to-bottom | without moving the text on the screen, reposition point |
| M-(n)      | digit-argument                    | repeat the next command (N) times                       |
| C-u (n)    | universal-argument                | repeat the next command (N) times                       |
| M-g c      | goto-char                         | goto char (N) of file                                   |
| M-g M-g    | goto-line                         | goto line (N) of file                                   |
|------------+-----------------------------------+---------------------------------------------------------|

** Files

|------------+--------------------------+---------------------------------------------------------------------|
| Keystrokes | Command Name             | Action                                                              |
|------------+--------------------------+---------------------------------------------------------------------|
| C-x C-f    | find-file                | find file and read it in a new buffer                               |
| C-x C-v    | find-alternate-file      | read and alternate file replacing the one with (C-x C-f)            |
| C-x i      | inset-file               | insert file at cursor position                                      |
| C-x l      | -                        | Report number of lines on current page(how many before-after point) |
| C-x C-s    | save-buffer              | save current buffer in visited file if modified                     |
| C-x s      | save-some-buffer         | giving the choice which buffer to save or not.                      |
| C-x C-w    | write-file (Rename-file) | write buffer contents (save buffer as a new file)                   |
| C-x C-c    | save-buffers-kill-emacs  | Offer to save each buffer, then kill Emacs                          |
| C-z        | suspend-emacs            | Suspend Emacs temporarily                                           |
|------------+--------------------------+---------------------------------------------------------------------|

* Modeline

*Modeline:* /Near the bottom of each window is special line, which called Modeline./

|-----------+----------------------------------------------|
| Character | Meaning                                      |
|-----------+----------------------------------------------|
| =--=      | buffer has not been modified                 |
| =**=      | buffer has been modified                     |
| =%%=      | read only mode; buffer has not been modified |
| =%*=      | read only mode; buffer has been modified     |
|-----------+----------------------------------------------|

* Search

|------------+-------------------------+-----------------------------------------------------------------------------------------------------------|
| Keystrokes | Command Name            | Action                                                                                                    |
|------------+-------------------------+-----------------------------------------------------------------------------------------------------------|
| C-s        | isearch-forward         | start incremental search forward by search string, also find next occurrence (forward) of search string   |
| C-r        | isearch-backward        | start incremental search backward by search string, also find next occurrence (backward) of search string |
| C-s C-s    | isearch-repeat-forward  | repeat previous search                                                                                    |
| C-r C-r    | isearch-repeat-backward | repeat previous search backward                                                                           |
| C-s C-w    | isearch-yank-word       | start with the word the cursor is on as search string                                                     |
| C-s C-y    | isearch-yank-line       | start with the text from cursor position to the end of the line as search string                          |
| C-s M-y    | isearch-yank-kill       | start with the text from kill ring as search string                                                       |
| M-p        |                         | select PREVIOUS search string                                                                             |
| M-n        |                         | select NEXT search string                                                                                 |
|------------+-------------------------+-----------------------------------------------------------------------------------------------------------|

* Mark, region and kill-ring

|------------+--------------------------+------------------------------------------------|
| Keystrokes | Command Name             | Action                                         |
|------------+--------------------------+------------------------------------------------|
| C-@/C-SP   | set-mark-command         | mark the beginning (or end) of a region        |
| C-x C-x    | exchange-point-and-mark  | exchange location of cursor and mark           |
| M-h        | mark-paragraph           | mark paragraph                                 |
| M-w        | kill-region-save         | copy the region (so it can be pasted with =C-y=) |
| C-x C-p    | mark-page                | mark the page                                  |
| C-x h      | mark-whole-buffer        | mark buffer                                    |
| M-@        | set mark after next word | do not move point(cursor)                      |
| ESC n M-@  | "   " more than one word | use a prefix argument(n)                       |
|------------+--------------------------+------------------------------------------------|

** make cursor jump back to the previous position

- C-SPC C-SPC
  - set mark (activates and then deactivates region) pushes the current position
    to the mark ring (without leaving it active).
  - Emacs let you save the position of the cursor by pressing ~C-space C-space~.

- C-u C-SPC
  - When you are in another part of the document, jump back with ~C-u C-space~.
  - move to previous mark pops the mark ring, jumping to the previous
    position. You can use this repeatedly to navigate through the entire ring.

** Exchange point and mark

- C-x C-x (=exchange-point-and-mark=)
  - Which is very useful for jumping between two locations. It also activates
    the =mark-or-region=, use =C-SPC= to clear the highlighting.

  - Put the mark where point is now, and point where the mark is now.  This
    command works even when the mark is not active, and it reactivates the mark.

  - If Transient Mark mode is on, a prefix ARG deactivates the mark if it is
    active, and otherwise avoids reactivating it.  If Transient Mark mode is
    off, a prefix ARG enables Transient Mark mode temporarily.

** Block editing
- =C-x C-@= */* =C-x C-SPC=

  - (pop-global-mark) Pop off global mark ring and jump to the top location.
    The global mark ring is updated automatically

* Getting Help
** Meta Help
The help system is simple. Type =C-h= (or =F1=) and follow the directions. If you are a first-time user, type =C-h= =t= for TUTORIAL.
|------------+-------------------------+------------------------------------------------------------------------|
| Keystrokes | Command Name            | Action                                                                 |
|------------+-------------------------+------------------------------------------------------------------------|
| C-h        | help command            | enter the online help system                                           |
| C-h t      | help-with-tutorial      | start Emacs TUTORIAL                                                   |
| C-h ?      | help-for-help           | runs the command help-for-help                                         |
| C-h C-h    | help-for-help           | -                                                                      |
| C-h C-a    | about-emacs             | Display the ~*About GNU Emacs*~ buffer.                                  |
| C-h l      | view-lossage            | Display last few input keystrokes and the commands run.                |
| C-h m      | describe-mode           | help information for the current buffers modes                         |
| C-h k      | describe-key            | gives online help for a given keystroke sequence                       |
| C-h f      | describe-function       | Display the full documentation of FUNCTION                             |
| C-h x      | describe-command        | help information for a command (a function available using =M-x=).       |
| C-h b      | describe-bindings       | showing a list of all defined keys, and their definitions.             |
| C-h c      | describe-key-briefly    | print the name of the functions KEY-LIST invokes                       |
| C-h w      | where-is                | Print message listing key sequences that invoke the command DEFINITION |
| C-h h      | (view-hello-file)       | display the HELLO file, which lists many languages and characters      |
| C-h a      | apropos-command PATTERN | Show commands that match PATTERN                                       |
| C-h i      | runs the command info   | enter Info, the documentation browser                                  |
| C-h i m    | -                       | go to info and SELECT *m* for menu                                       |
|------------+-------------------------+------------------------------------------------------------------------|

* Killing and Deleting

|------------+-------------------------+--------------------------------------------------|
| Keystrokes | Command Name            | Action                                           |
|------------+-------------------------+--------------------------------------------------|
| C-d        | delete-char             | delete char under cursor                         |
| BS         | delete-backward-char    | delete previous char                             |
| M-d        | kill-word               | delete next word                                 |
| M-BS       | backward-kill-word      | delete previous word                             |
| C-k        | kill-line               | delete from the cursor to end-of-line            |
| M-k        | kill-sentence           | delete next sentence                             |
| C-x BS     | backward-kill-sentence  | delete previous sentence                         |
| C-y        | yank                    | restore what you've deleted (YANK LAST KILL)     |
| M-y        | yank-pop                | REPLACE YANKED with PREVIOUS KILL                |
| C-w        | kill-region             | delete a marked region                           |
| M-w        | kill-region-save        | copy the region (so it can be pasted with =C-y=) |
| (none)     | kill-paragraph          | delete next paragraph                            |
| (none)     | backward-kill-paragraph | delete previous paragraph                        |
|------------+-------------------------+--------------------------------------------------|

- SHIFT-C-BS
  - Delete entire line the point is on
- C-0 C-k or C-u 0 C-k
  - Delete from point to begining of line

- C-u BS
  - will delete 4 =spaces= backwards.

Equivalent bindings would be:

M-4 <backspace>
C-4 <backspace>

- M-\
  - Delete all SPACES & TABS around point (delete-horizontal-space).

- M-SPC
  - Deletes all spaces and tabs around point, leaving one space

- M-^
  - (delete-indentation) command for joining multiple lines into one line

- C-x C-o
  - get rid off all blank line around current line except one.

- M-x (delete-whitespace-rectangle)


- M-z CHAR
  - from cursor upto char

- C-t
  - Transpose two characters on either side of
    point and move point forward by one

* Undo/Redo
- C-/ or C-_
  - Undo
- C-?
  - Redo
- C-g C-/
  - (undo-redo) REDO.

- =M-x= =revert-buffer=
  - If you want to undo all-changes made since you last saved the file.

* Tweaks
** switch themes
- C-c T
  - themes list will appear, choose your desired one and press =Enter=.
** Toggle mode

- C-c t
  - toggle ON/OFF transparency.
- C-[f5]
  - toggle (=display-line-numbers-mode-relative=)
* Advance Editing

** Text conversion and transposition

- Text conversion and transposition
+ M-l, M-u, M-c: lowercase, uppercase, capitalize first character
+ C-t, M-t, C-M-t, C-x C-t: transpose character, word, expression, line

|------------+----------------------------------------------|
| Keystrokes | Description                                  |
|------------+----------------------------------------------|
| M-l        | change following word to lowercase           |
| M-u        | change following word to uppercase           |
| M-c        | change following word initial letter capital |
| M-- l      | change previous word to lowercase            |
| M-- u      | change previous word to uppercase            |
| M-- c      | change previous word initial letter capital  |
| C-t        | Transpose two adjacent characters            |
| M-t        | Transpose two adjacent word                  |
| C-M-t      | Transpose two adjacent expression            |
| C-x C-t    | Transpose two adjacent consecutive lines     |
|------------+----------------------------------------------|

* Buffers, Windows and Frames
** Emacs Buffer
- The Emacs object containing text
- Buffer *!=* file: a file can be opened in multiple buffers
- =C-x= =C-f=, =C-x= =C-b=, =C-x= =k=: open file, switch buffer, kill buffer

** Emacs Window

- The Emacs object showing a buffer
- Emacs' window != window in Linux/Windows (Emacs calls it /frame/)
- C-x 0, 1, 2, 3: delete, maximize, split horizontally/vertically
- C-x {, }, ^, _: shrink, enlarge horizontally/vertically

|-----------------+-------------------------------------------|
| Keystrokes      | Description                               |
|-----------------+-------------------------------------------|
| C-x 0           | Delete the selected window                |
| C-x 1           | Delete all windows except selected window |
| C-x 2           | split selected window vertically          |
| C-x 3           | split selected window horizontally        |
| C-x o           | move cursor to the next(other) window     |
| C-x }           | make selected window wider                |
| C-x {           | make selected window narrower             |
| C-x ^           | make selected window larger               |
| =shrink-window= | make selected window smaller              |
|-----------------+-------------------------------------------|

|---------------+---------------------------------------------------------|
| Keystrokes    | Description                                             |
|---------------+---------------------------------------------------------|
| C-x b         | Display a different buffer in selected window           |
| C-x b         | Create a new buffer in selected window                  |
| C-x 4 b       | Display a different buffer in next window               |
| =C-x C-b= =o= | open a file in other-window from *Buffer List*          |
| C-x 4 C-o     | same as(~C-x~ ~4~ ~b~) but don't change selected window |
| C-x C-b       | Display a list of all buffers                           |
| C-x k         | kill (delete) a buffer                                  |
| C-x 4 C-f     | read contents of file into next window                  |
| C-x 4 f       | same as (C-x 4 C-f)                                     |
| C-x 4 r       | same as (C-x 4 C-f), but in read-only mode              |
|---------------+---------------------------------------------------------|
*Note:* Use =C-x= =b= for creating a new buffer only when you don't want to save.

** Emacs Frame
- C-x 5 2
  - to open a new frame
- C-x 5 f [title of your new frame]
  - open a frame on particular name of file.
- C-x 5 b
  - to move to a buffer and put it in a new frame.
- C-x 5 o
  - to go to another frame

* Repeat Command
- C-x z

- C-u C-n C-x z z z z     - next-line CHAIN

- C-/ C-x z z z z         - UNDO-CHAIN

* Built in Programs
You can quit any Emacs built-in-program by pressing =q=.
** Dired Buffer

|------------+----------------------------------+--------------------------------------------------------------------------------|
| Keystrokes | Command Invoked                  | Description                                                                    |
|------------+----------------------------------+--------------------------------------------------------------------------------|
| C-x d      | dired-at-point                   | Start Dired, defaulting to file at point                                       |
| C-x C-j    | dired-jump                       | to the name of the current file, in Dired                                      |
| RET        | -                                | to select directory of current file                                            |
| g          | Refresh dired buffer             | Refresh to get the recent update. Refresh by reading the directory again.      |
| h          |                                  | Display help summery                                                           |
| C          | dired-do-copy                    | Copy all marked files, or copy the current file.                               |
| R          | dired-do-rename                  | Rename current file or all marked files. (to rename, give the file a new name) |
| R          | Move file in another Directory   | (write down the path and name of directory)                                    |
| C-o        | dired-display-file               | Preview file but stay in Dired buffer.                                         |
| C-u k      | dired-do-kill-lines              | Remove section.                                                                |
| X          | dired-do-shell-command           | Execute shell command on file.                                                 |
| Q          | dired-do-find-regexp-and-replace | Query replace marked files, <space> accept, n decline and C-x s to save all.   |
| +          | dired-create-directory           | Create directory.                                                              |
| ^          | dired-up-directory               | Go up one directory.                                                           |
|            | find-name-dired                  | Recursively find a file.                                                       |
|------------+----------------------------------+--------------------------------------------------------------------------------|

+ *Mark/Unmark*
|------------+--------------------------------------------------------|
| Keystrokes | Description                                            |
|------------+--------------------------------------------------------|
| m          | Mark current file/directory, move cursor down.         |
| BS         | Unmark current file/directory, move cursor up.         |
| u          | Unmark not-current file/directory, move cursor down.   |
| U          | Unmark all file/directory.                             |
| R          | Move marked file or current file to another directory. |
|------------+--------------------------------------------------------|

+ *Deleting*
|------------+----------------------------------|
| Keystrokes | Description                      |
|------------+----------------------------------|
| d          | Flag file for Deletion.          |
| x          | Delete files flagged by (=d=).     |
| D          | Delete directly without marking. |
|------------+----------------------------------|

+ *Writable  Dired*
|------------+----------------------------------------------|
| Keystrokes | Description                                  |
|------------+----------------------------------------------|
| C-x C-q    | Enter into editable mode from read-only mode |
| C-c C-c    | Save and quit editing mode                   |
| C-c Esc    | Abort changes and quit editing mode          |
|------------+----------------------------------------------|

*** Regular Expression
In order to mark the items that are matched by the search terms.
+ =%= and then =m=
Let's search for all the files whose ending is =.el= by entering /\.el/ in minibuffer.

Now you can see item has been marked is by the astrict(=*=) sign on the left side of window.

+ Toggle the mark by pressing: *t*
It'll reverse the matching terms. So instead of matching items, it do reverse of selection.

** The Info manual
|------------+-------------------------------------------|
| Keystrokes | Purpose                                   |
|------------+-------------------------------------------|
| [, ]       | previous/next node                        |
| l, r       | go back/forward History                   |
| n, p       | previous/next sibling node                |
| u          | goes up one level to a parent node        |
| SPC        | scroll one screen at a time               |
| TAB        | cycle through cross-references and links  |
| RET        | opens the active link                     |
| m          | prompts for a menu item name and opens it |
| q          | close the Info Buffer                     |
|------------+-------------------------------------------|
** customize
- Tools to help you change user options.
** eww
*eww*: Emacs web browser.
** ses
*ses*: create and edit spreadsheet files.
** Calender
- *Calendar* and *Diary*
* Shells

|-------------+-------------------------+-------------------------------------------------------------------|
| Keystrokes  | Command Name            | Description                                                       |
|-------------+-------------------------+-------------------------------------------------------------------|
| M-!         | shell command           | Execute string COMMAND in inferior shell; display output, if any. |
| M-‚îÇ         | shell-command-on-region | Execute string COMMAND in inferior shell with region as input.    |
| M-x (shell) |                         | start a separate shell in it's own Buffer.                        |
| C-u M-‚îÇ     |                         | run shell command in buffer region                                |
|-------------+-------------------------+-------------------------------------------------------------------|
*e.g.* First select the region for formatted then enter into shell by pressing ~M-|~.
  And then enter command ~fmt -w 80~ to set width and show result on minibuffer.

** eshell

Enter on eshell:
- C-!

*** Command History and Prompt Key Bindings

Eshell comes with a feature-rich command history facility.  Because Eshell does not use comint-mode it does not have all the history features available to it, but most of the common ones do exist.

- M-r / M-s
  - Search backwards or forwards for a command by regexp
- M-p / M-n
  - Goes backwards or forwards in the command history list
- C-c C-p / C-c C-n
  - Jump to the previous or next command prompt in Eshell
- C-c M-r / C-c M-s
  - Jumps to the previous or next command that shares the command currently used as input. So it jumps to other instances of the command foo if that is the current input.
- C-c C-o
  - Kills the output of the previous command.
- C-a / C-e
  - Move to the beginning or end of line.

    Unfortunately, the search-as-you-type history search in M-x shell (bound to M-r) is not implemented in Eshell.

Because I program a lot, I tend to use M-m instead of C-a to move to the beginning of the line. M-m skips indentation and moves to the first non-whitespace char, unlike C-a.

That command does not work in Eshell, for obvious reasons, but you can rebind it to the same key as C-a:

#+BEGIN_SRC emacs-lisp
  (define-key eshell-mode-map (kbd "M-m") 'eshell-bol)
#+END_SRC

*** History Interaction

You can rewrite previous commands found in Eshell‚Äôs history. The syntax is similar to what you find in bash, but it‚Äôs just a subset of the most common features. It‚Äôs probably easier to refer you to the bash info manual for detailed information on how the history interaction works. I‚Äôve included a small table below that describes most of the history syntax Eshell supports.

You may also want to read my article on Shell & Comint Secrets: History commands. Although it concerns comint-mode-derived things, it‚Äôs useful to know about anyway.

- =!!=
  - Repeats the last command
- =!ls=
  - Repeats the last command beginning with ls
- =!?ls=
  - Repeats the last command containing ls
- =!ls:n=
  - Extract the nth argument from the last command beginning with ls
- =!ls<tab>=
  - Using pcomplete, show completion results matches ls
- =^old^new=
  - Quick substitution. Using the last command, replaceold with new and run it again. Appears to be buggy.
- =$_=
  - Returns the last parameter in the last executed command.

Eshell also has some support for bash history modifiers (like !!:s/old/new/) and the bash reference on history interaction would be a good place to brush up on that.
Commandline Interaction
The Eshell Prompt

You can customize the Eshell prompt by modifying eshell-prompt-function, a variable that takes a function that defines what the prompt should contain. By relegating prompt configuration to elisp you can do just about anything you like with it. The only problem is, of course, that Eshell will need to be told what the prompt ‚Äúlooks‚Äù like, so you must also edit the variable eshell-prompt-regexp so Eshell knows what the prompt is.

Instead of going to the trouble of changing it yourself, you can give the package Eshell prompt extras a try.
The Command Line

You can use \ to escape newlines and it supports rudimentary multi-line input that way.

Another way of doing multi-line literal strings is with single quotes: begin a single quote and hit enter, and you are free to enter text until the closing quote delimiter is encountered. If you use double quotes Eshell will expand subshell commands and do variable expansion. In this sense it‚Äôs quite similar to bash, though without the support for bash heredocs.

Due to the way Eshell works, you can even go back and modify the text you entered, in quotes.
Useful Keybindings

Eshell comes equipped with a couple of quality-of-life improvements that make interacting with Emacs and Eshell a lot easier.

- C-c M-b
  - Inserts the printed buffer name at point
- C-c M-i
  - Inserts the printed process name at point
- C-c M-v
  - Inserts an environment variable name at point
- C-c M-d
  - Toggles between direct input and delayed input (send on RET).
 Useful for some programs that don‚Äôt work correctly with buffered input.

** Shell History Ring

- M-p / C-UP
  - Fetch the next earlier old shell command (comint-previous-input).

- M-n / C-DOWN
  - Fetch the next later old shell command (comint-next-input).

- M-r
  - Begin an incremental regexp search of old shell commands (comint-history-isearch-backward-regexp).

- C-c C-x
  - Fetch the next subsequent command from the history (comint-get-next-from-history).

- C-c .
  - Fetch one argument from an old shell command (comint-input-previous-argument).

- C-c C-l
  - Display the buffer‚Äôs history of shell commands in another window (comint-dynamic-list-input-ring).

** Formatting paragraph with shell cmnd

- C-h i m emacs RET - guide to learning Emacs Lisp for non-programmers for
  reference. * The Emacs Lisp Reference *
* Emacs-client

An Emacs server creates a special emacs process that listens on a socket for connecting to it. This way the initialisation is already done before you connect to it and all configurations are already loaded. This is the actual "slow" part of emacs. And is a bit similar to starting python, which also needs to load its libraries at start.

With the emacs server running, you can connect to it using the emacsclient program.

#+BEGIN_SRC sh
  alias vim='emacsclient -nw'
#+END_SRC

** What is so cool about the emacs server?

Saving a lot of response time and making working with emacs feel much faster is the obvious advantage. However, there is a much bigger one:

With the emacs server, you can connect to it from the terminal and X Window. Because the emacs server also manages the buffers ("open files" for non-emacs users), you can view the same open file from the terminal or an x window.

Emacs does "chunk-wise" completion of these strings, too? For example,
 M-x j-p-p-b <tab>
completes to
 M-x json-pretty-print-buffer

* SEXPS

Selecting words or sexps without moving the cursor.
|---------------------+--------------+------------------------------------------------------|
| Keystrokes          | Command Name | Action                                               |
|---------------------+--------------+------------------------------------------------------|
| C-M-SPC M-w         |              | This does not move the cursor                        |
| C-M-SPC C-M-SPC M-w |              | If you want to select the next two words after point |
| C-M-SPC C-w         |              | Killing next word or sexp                            |
| C-M-K               |              | Killing next word or sexp                            |
|---------------------+--------------+------------------------------------------------------|

* Fold/Unfold Blocks

Fold/Unfold code blocks with =hs-minor-mode=

|-------------+------------------+-----------------+-------------------------------------------|
| Key binding | Hideshow mode    | Key binding     | Outline minor mode                        |
|-------------+------------------+-----------------+-------------------------------------------|
| C-c @ C-a   | hs-show-all      | C-c @ TAB       | outline-show-children                     |
| C-c @ C-c   | hs-toggle-hiding | C-c @ C-k       | outline-show-branches                     |
| C-c @ C-d   | hs-hide-block    | C-c @ C-o       | outline-hide-other                        |
| C-c @ C-e   | hs-toggle-hiding | C-c @ C-q       | outline-hide-sub-levels                   |
| C-c @ C-h   | hs-hide-block    | C-u n C-c @ C-l | Hide all blocks n levels below this block |
| C-c @ C-l   | hs-hide-level    |                 |                                           |
| C-c @ C-s   | hs-show-block    |                 |                                           |
| C-c @ C-t   | hs-hide-all      |                 |                                           |
| C-c @ ESC   | Prefix Command   |                 |                                           |
| C-c @ C-M-h | hs-hide-all      |                 |                                           |
| C-c @ C-M-s | hs-show-all      |                 |                                           |
|-------------+------------------+-----------------+-------------------------------------------|


+ This is irritating on two levels.
1. The key bindings are on a difficult to use keymap.
2. There‚Äôs no easy entry point and there are too many commands to do simple
   tasks.

- These variables can be used to customize Hideshow mode:
+ If non-nil, =C-c= =@= =C-M-h= (=hs-hide-all=) hides comments too.

- ~hs-isearch-open~
 - Specifies what kind of hidden blocks to open in =isearch-mode=.
The value should be one of these four symbols.

- =code= (open only code blocks)
- =comment= (open only comments)
- ~t~ (open both code blocks and comments).
- ~nil~ (open neither code blocks nor comments)

- ~hs-special-modes-alist~
 - A list of elements, each specifying how to initialize Hideshow variables for
   one major mode. See the variable's documentation string for more information.

* Bookmarks

Note that some commands (especially ones which are liable to move you an unknown
or arbitrary distance from your original location) will automatically push to
the mark ring so that you can use ~C-u C-SPC~ to return afterwards. This includes
=isearch=, so after using =C-s= to go somewhere, you can easily jump back again.

| Shortcut | Command Invoked     | Description            |
|----------+---------------------+------------------------|
| C-x r m  | bookmark-set        | Create / set bookmark. |
| C-x r b  | bookmark-jump       | Open bookmark.         |
| C-x r l  | bookmark-bmenu-list | List bookmarks.        |

+ Delete Bookmark
  - go to Bookmark and Select by pressing ~d~ than to Delete press ~x~

* Registers

If you're taking advantage of register functionality in elisp, use some
non-conflicting symbol for the name, rather than a char, so that you can't
conflict with interactively-set registers (unless, of course, you want to do
that). \\
The register retains this information until you store something else in it.

- C-x r SPC r
  - =point-to-register=, followed by a character r. Record the position of point and the current buffer in register =r=.

- C-x r j r
  - =jump-to-register= Jump to the position and buffer saved in register =r=.

(The mark is not pushed if point was already at the recorded position, or in successive calls to the command.) The contents of the register are not changed, so you can jump to the saved position any number of times.

If you use C-x r j to go to a saved position, but the buffer it was saved from has been killed, C-x r j tries to create the buffer again by visiting the same file. Of course, this works only for buffers that were visiting files.

** Save Positions in Registers
- C-x r SPC
  - runs point-to-register

- C-x r j
  - runs jump-to-register
  Type any character to specify a register when prompted.

- C-x r C-SPC

- C-x r C-@
  - (point-to-register REGISTER &optional ARG)

* Regular Expression

Basic character you can use to create a regular expression.
|-----------+---------------------------------------------------------------------------------------------------------|
| Character | Description                                                                                             |
|-----------+---------------------------------------------------------------------------------------------------------|
| (char)    | any regular character matches itself.                                                                   |
| .         | match any single character except =RET= and (like *?* in file name).                                        |
| *         | match zero or more of the preceding char.                                                               |
| +         | match one or more of the preceding char.                                                                |
| ?         | match exactly zero or more of the preceding char.                                                       |
| ^         | match the beginning of a line.                                                                          |
| $         | match the end of a line.                                                                                |
| \<        | match the beginning of a word.                                                                          |
| \>        | match the end of a word.                                                                                |
| \b        | match the beginning or end of a word.                                                                   |
| \B        | match anywhere not at the beginning or end of a word.                                                   |
| \d        | matches any single digit(0-9).                                                                          |
| \D        | matches any char but a digit.                                                                           |
| \`        | match the beginning of the buffer.                                                                      |
| \'        | match the end of the buffer.                                                                            |
| \(char)   | quotes a special character.                                                                             |
| []        | match one of the enclosed characters.                                                                   |
| [^ ]      | match any character that is not enclosed.                                                               |
| \s        | match any whitespace character, space, a newline, a tab, a carriage, return, a formfeed or a backspace. |
| \S         | matches any char except whitespace.                                                                     |
| \w        | matches any "word" char (upper-lower letters, digit, underscore).                                       |
| \W        | matches any char but not these (upper-lower letters, digit, underscore).                                |
|-----------+---------------------------------------------------------------------------------------------------------|
*e.g.* search for the characters (Welcome) at the beginning of a line, press =M-C-s= and type =^Welcome=.

* Keyboard Macros

| Shortcut        | Command Invoked           | Description                                                          |
|-----------------+---------------------------+----------------------------------------------------------------------|
| C-x (           | kmacro-start-macro        | Define keyboard macro. (Start recording key strokes)                 |
| C-x )           | kmacro-end-macro          | End keyboard macro definition. (Stop and save recording key strokes) |
| C-x e           | kmacro-end-and-call-macro | Playback keyboard macro, can just keep pressing e after first press. |
| C-x C-k <space> | kmacro-step-edit-macro    | Open keyboard macro debugger.                                        |
| C-x C-k e       | edit-kbd-macro            | Enter macro editor, (C-c C-c) to finish editing.                     |
| C-x C-k n       | kmacro-name-last-macro    | Save the keyboard macro for later use.                               |
|                 | insert-kbd-macro          | Insert a saved macro into the file, in Emacs lisp.                   |

- =C-a= =C-SPC= =C-n= =M-w= =C-y=	---Duplicate a whole line
- =C-a= =C-k= =C-k= =C-y= =C-y=	---Duplicate a whole line

- ~M-x~ =eval-region=
- ~M-x~ =eval-buffer=
- ~M-x~ =load-file= =~/.emacs.d/init.el=
- ~M-x~ =revert-buffer=

narrow-to-region (C-x n n) Then widen (C-x n w)

move the point to the end of any sexp and press
- C-x C-e
  - to execute just that sexp in elisp program.  Usually it's not necessary to reload the whole file if you're just changing a line or two.

- M-: (load user-init-file)
you type it in Eval: prompt (including the parentheses)
user-init-file is a variable holding the =~/.emacs= value (pointing to the configuration file path) by default
(load) is shorter, older, and non-interactive version of (load-file); it is not an emacs command (to be typed in M-x) but a mere elisp function

- M-/
  - EXPAND ABBREVIATION - the command abbrev-expand, is an autoloaded interactive compiled Lisp function

- C-M-o
  - Split line at point; text on the line after point becomes a new line indented to the same column that it now starts in (split-line).
- M-m
  - Move (forward or back) to the first nonblank character on the current line (back-to-indentation).
- C-M-\
  - Indent several lines to same column (indent-region).
- C-q TAB
  - Insert a literal \T into your code somewhere.
- C-x TAB
  - Shift block of lines rigidly right or left (indent-rigidly).
- M-i
  - Indent from point to the next prespecified tab stop column (tab-to-tab-stop).
- M-x =indent-relative=
  - Indent from point to under an indentation point in the previous line.

- C-5 C-x TAB
  - you can specify the number of spaces to indent by using a prefix argument

- C-x r t or =M-x= =string-rectangle=
  - This one inserts text at every line in the rectangle.

%% Start by setting the mark at the beginning of the first line, and move your cursor to the first character of the last line you want to prefix:
#+BEGIN_EXAMPLE
*Hello
There
‚ñÆI am some code
#+END_EXAMPLE

%% Then use C-x r t, enter your prefix (I said) and press RET. This adds the text to each line in the rectangle:
#+begin_example
  I said Hello
  I said There
  I said I am some code
#+end_example

%% If you don't line up your cursor on the same column as your mark, it will overwrite that part of the rectangle:
#+BEGIN_EXAMPLE
*Hello
There
I am‚ñÆ some code
#+END_EXAMPLE

%% with the same command results in:
#+BEGIN_EXAMPLE
I said o
I said e
I said  some code
#+END_EXAMPLE

- C-x r t       - string-rectangle (used to insert any arbitrary text (spaces included) in a selected region.)

%% Let's say you have this block of text and you want to insert 5 spaces in front of all lines.
#+begin_example
abc
def
ghi
#+end_example

- C-x r t M-5 SPC RET   - That will give the below force indented text.
#+BEGIN_EXAMPLE
abc
def
ghi
#+END_EXAMPLE

- IMHO the standard way is:
   1) Go to the top of your buffer.
   2) Type C-M-% for query-replace-regexp.
   3) Input ^\s-+ as regular expression and RET. (See explanation below.)
   4) Leave the replacement string empty, i.e., press RET again.
   5) You are prompted by query-replace-regexp in the minibuffer.
   6) Press ! to perform all replacements at once.

Explanation of the regular expression:
1) The caret ^ stands for the beginning of line.
2) The \s- stands for any character designated as space by the current modes syntax table.
3) The + stands for one or more contiguous matches.

* Miscellaneous
|------------+------------------------------+-------------------------------------------------------------------------------------------|
| Keystrokes | Command Name                 | Action                                                                                    |
|------------+------------------------------+-------------------------------------------------------------------------------------------|
| M-=        | count-words-region START END | Count the lines, number of words and characters in the region.                            |
| C-u num    | universal-argument           | begin a numeric argument for the following command.                                       |
| M--        | negative-argument            | begin a negative numeric argument for the next command.                                   |
| C-q char   | quoted-insert                | read next input character and insert it. This is useful for inserting control characters. |
|------------+------------------------------+-------------------------------------------------------------------------------------------|

** Enter Numeric values
Insert integer trough a significant point
- ~C-10~ ~C-u~ ~0~
  - will give =10= zeros after the point.

- =C-x C-b= =o=
  - open a file in other-window from *Buffer List*

* Spelling Check

Interface To Spell (Ispell) and On The Fly Spell (Flyspell)

|----------+------------------------------------+------------------------------------------------------------------|
| Shortcut | Command Invoked                    | Description                                                      |
|----------+------------------------------------+------------------------------------------------------------------|
| M-$      | ispell-word                        | check and correct spelling of word under or before the cursor.   |
| M-TAB    | completion-at-point                | complete the word before point based on the spelling dictionary. |
| C-M i    | -                                  | -                                                                |
| C-c $    | flyspell-correct-word-before-point | Correct word before point.                                       |
| M-x      | ispell-buffer                      | check the current buffer for spelling errors.                    |
| -        | ispell-region                      | check a region for spelling errors.                              |
| -        | flyspell-mode                      | Enable Fly-spell mode, which highlights all misspelled words.    |
| -        | flyspell-prog-mode                 | Enable Fly-spell mode for comments and strings only.             |
| -        | flyspell-buffer                    | Check and correct spelling in the buffer.                        |
|----------+------------------------------------+------------------------------------------------------------------|

* Projectile
- Simply open any file in the git project using =C-x C-f= and then try running
  command ~C-c~ ~p~ ~f~.

+ Opening a file in a git project will make projectile recognize the project.

- I think your project is indeed considered a project by =projectile= only if
  you have a =.git= folder in it (did you forget to =git init=?). I'm not seeing
  one in your case. You can alternatively add a =.projectile= file
  instead. Everything in that folder containing the =.projectile= file and all
  subfolders will be considered part of the same project.

* ORG
This topic =Org= is pretty huge on it's own. So, I made a separate manual for
=org-mode= and moved everything about =org-mode= there. \\
Please, check this out here: üëâüèΩ [[https://github.com/Likhon-baRoy/org-notes/blob/main/Emacs/org_user-menual.org][ORG-user-manual]].
